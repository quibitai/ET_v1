"""
Google Chat MCP Tools

This module provides MCP tools for interacting with Google Chat API.
"""
import logging
import asyncio
from typing import Optional

from mcp import types
from googleapiclient.errors import HttpError

# Auth & server utilities
from auth.service_decorator import require_google_service
from core.server import server
from core.utils import handle_http_errors

logger = logging.getLogger(__name__)

def ensure_space_id_format(space_id: str) -> str:
    """Ensure space ID has the proper 'spaces/' prefix format."""
    if not space_id.startswith('spaces/'):
        return f'spaces/{space_id}'
    return space_id

@server.tool()
@require_google_service("chat", "chat_spaces_read")
@handle_http_errors("list_spaces")
async def list_spaces(
    service,
    user_google_email: str,
    page_size: int = 100,
    space_type: str = "all"  # "all", "room", "dm"
) -> str:
    """
    Lists Google Chat spaces (rooms and direct messages) accessible to the user.

    Returns:
        str: A formatted list of Google Chat spaces accessible to the user.
    """
    logger.info(f"[list_spaces] Email={user_google_email}, Type={space_type}")

    # Build filter based on space_type - temporarily disable filtering to test basic functionality
    filter_param = None
    # TODO: Fix filter syntax - currently causing API errors
    # if space_type == "room":
    #     filter_param = 'spaceType = "SPACE"'
    # elif space_type == "dm":
    #     filter_param = 'spaceType = "DIRECT_MESSAGE"'

    request_params = {"pageSize": page_size}
    # Temporarily disable filtering
    # if filter_param:
    #     request_params["filter"] = filter_param

    response = await asyncio.to_thread(
        service.spaces().list(**request_params).execute
    )

    spaces = response.get('spaces', [])
    if not spaces:
        return f"No Chat spaces found for type '{space_type}'."

    output = [f"Found {len(spaces)} Chat spaces (type: {space_type}):"]
    
    # Helper function to get participant names for DM spaces
    async def get_dm_participant_name(space_id: str, current_user_email: str) -> str:
        try:
            logger.info(f"[get_dm_participant_name] Getting participants for space: {space_id}")
            
            # Get space members
            members_response = await asyncio.to_thread(
                service.spaces().members().list(parent=space_id).execute
            )
            members = members_response.get('memberships', [])
            logger.info(f"[get_dm_participant_name] Found {len(members)} members")
            
            # Collect all participants for debugging
            all_participants = []
            other_participant = None
            
            # Find the other participant (not the current user)
            for member in members:
                member_user = member.get('member', {})
                member_type = member_user.get('type', 'UNKNOWN')
                
                if member_type == 'HUMAN':
                    # Extract email from the 'name' field (format: users/email@domain.com)
                    member_name_field = member_user.get('name', '')
                    if member_name_field.startswith('users/'):
                        member_email = member_name_field.replace('users/', '')
                    else:
                        member_email = member_name_field.split('/')[-1] if '/' in member_name_field else member_name_field
                    
                    member_display_name = member_user.get('displayName', '')
                    
                    all_participants.append({
                        'email': member_email,
                        'displayName': member_display_name,
                        'isCurrentUser': member_email == current_user_email
                    })
                    
                    # Skip the current user, save the other participant
                    if member_email != current_user_email:
                        other_participant = {
                            'email': member_email,
                            'displayName': member_display_name
                        }
            
            logger.info(f"[get_dm_participant_name] All participants: {all_participants}")
            
            if other_participant:
                if other_participant['displayName']:
                    result = f"DM with {other_participant['displayName']} ({other_participant['email']})"
                else:
                    result = f"DM with {other_participant['email']}"
                logger.info(f"[get_dm_participant_name] Returning: {result}")
                return result
            
            logger.warning(f"[get_dm_participant_name] No other participant found")
            return "Direct Message (1:1 Chat)"
            
        except Exception as e:
            logger.error(f"Could not get participants for space {space_id}: {e}")
            return "Direct Message (1:1 Chat)"
    
    for space in spaces:
        space_name = space.get('displayName', '')
        space_id = space.get('name', '')
        space_type_actual = space.get('spaceType', 'UNKNOWN')
        
        # Better handling for different space types
        if space_type_actual == 'DIRECT_MESSAGE':
            if space_name:
                display_name = space_name
            else:
                # Try to get the other participant's name
                display_name = await get_dm_participant_name(space_id, user_google_email)
        elif space_type_actual == 'GROUP_CHAT':
            # For group chats, show as "Group Chat" if no name
            display_name = space_name if space_name else "Group Chat (Unnamed)"
        else:
            # For named spaces (rooms), use the display name or show as "Named Space"
            display_name = space_name if space_name else "Named Space"
        
        output.append(f"- {display_name} (ID: {space_id}, Type: {space_type_actual})")

    return "\n".join(output)

@server.tool()
@require_google_service("chat", "chat_spaces_read")
@handle_http_errors("get_messages")
async def get_messages(
    service,
    user_google_email: str,
    space_id: str,
    page_size: int = 50,
    order_by: str = "createTime desc"
) -> str:
    """
    Retrieves messages from a Google Chat space.

    Returns:
        str: Formatted messages from the specified space.
    """
    logger.info(f"[get_messages] Space ID: '{space_id}' for user '{user_google_email}'")

    # Get space info first
    space_info = await asyncio.to_thread(
        service.spaces().get(name=space_id).execute
    )
    space_name = space_info.get('displayName', 'Unknown Space')

    # Get messages
    response = await asyncio.to_thread(
        service.spaces().messages().list(
            parent=space_id,
            pageSize=page_size,
            orderBy=order_by
        ).execute
    )

    messages = response.get('messages', [])
    if not messages:
        return f"No messages found in space '{space_name}' (ID: {space_id})."

    output = [f"Messages from '{space_name}' (ID: {space_id}):\n"]
    for msg in messages:
        # Extract sender information properly from Google Chat API response
        sender_info = msg.get('sender', {})
        sender_name = sender_info.get('displayName', '')
        sender_email = sender_info.get('name', '')
        
        # If sender_email is in format "users/email@domain.com", extract just the email
        if sender_email.startswith('users/'):
            sender_email = sender_email.replace('users/', '')
        
        # Create a meaningful sender display
        if sender_name and sender_email:
            sender_display = f"{sender_name} ({sender_email})"
        elif sender_name:
            sender_display = sender_name
        elif sender_email:
            sender_display = sender_email
        else:
            sender_display = 'Unknown Sender'
        
        create_time = msg.get('createTime', 'Unknown Time')
        text_content = msg.get('text', 'No text content')
        msg_name = msg.get('name', '')

        output.append(f"[{create_time}] {sender_display}:")
        output.append(f"  {text_content}")
        output.append(f"  (Message ID: {msg_name})\n")

    return "\n".join(output)

@server.tool()
@require_google_service("chat", "chat_messages_create")
@handle_http_errors("send_message")
async def send_message(
    service,
    user_google_email: str,
    space_id: str,
    message_text: str,
    thread_key: Optional[str] = None
) -> str:
    """
    Sends a message to a Google Chat space.

    Returns:
        str: Confirmation message with sent message details.
    """
    logger.info(f"[send_message] Email: '{user_google_email}', Space: '{space_id}'")

    # Ensure space ID has proper format
    formatted_space_id = ensure_space_id_format(space_id)

    message_body = {
        'text': message_text
    }

    # Add thread key if provided (for threaded replies)
    request_params = {
        'parent': formatted_space_id,
        'body': message_body
    }
    if thread_key:
        request_params['threadKey'] = thread_key

    message = await asyncio.to_thread(
        service.spaces().messages().create(**request_params).execute
    )

    message_name = message.get('name', '')
    create_time = message.get('createTime', '')

    msg = f"Message sent to space '{formatted_space_id}' by {user_google_email}. Message ID: {message_name}, Time: {create_time}"
    logger.info(f"Successfully sent message to space '{formatted_space_id}' by {user_google_email}")
    return msg

@server.tool()
@require_google_service("chat", "chat_spaces_read")
@handle_http_errors("search_messages")
async def search_messages(
    service,
    user_google_email: str,
    query: str,
    space_id: Optional[str] = None,
    page_size: int = 25
) -> str:
    """
    Searches for messages in Google Chat spaces by text content.

    Returns:
        str: A formatted list of messages matching the search query.
    """
    logger.info(f"[search_messages] Email={user_google_email}, Query='{query}'")

    # If specific space provided, search within that space
    if space_id:
        response = await asyncio.to_thread(
            service.spaces().messages().list(
                parent=space_id,
                pageSize=page_size,
                filter=f'text:"{query}"'
            ).execute
        )
        messages = response.get('messages', [])
        context = f"space '{space_id}'"
    else:
        # Search across all accessible spaces (this may require iterating through spaces)
        # For simplicity, we'll search the user's spaces first
        spaces_response = await asyncio.to_thread(
            service.spaces().list(pageSize=100).execute
        )
        spaces = spaces_response.get('spaces', [])

        messages = []
        for space in spaces[:10]:  # Limit to first 10 spaces to avoid timeout
            try:
                space_messages = await asyncio.to_thread(
                    service.spaces().messages().list(
                        parent=space.get('name'),
                        pageSize=5,
                        filter=f'text:"{query}"'
                    ).execute
                )
                space_msgs = space_messages.get('messages', [])
                for msg in space_msgs:
                    msg['_space_name'] = space.get('displayName', 'Unknown')
                messages.extend(space_msgs)
            except HttpError:
                continue  # Skip spaces we can't access
        context = "all accessible spaces"

    if not messages:
        return f"No messages found matching '{query}' in {context}."

    output = [f"Found {len(messages)} messages matching '{query}' in {context}:"]
    for msg in messages:
        # Extract sender information properly from Google Chat API response
        sender_info = msg.get('sender', {})
        sender_name = sender_info.get('displayName', '')
        sender_email = sender_info.get('name', '')
        
        # If sender_email is in format "users/email@domain.com", extract just the email
        if sender_email.startswith('users/'):
            sender_email = sender_email.replace('users/', '')
        
        # Create a meaningful sender display
        if sender_name and sender_email:
            sender_display = f"{sender_name} ({sender_email})"
        elif sender_name:
            sender_display = sender_name
        elif sender_email:
            sender_display = sender_email
        else:
            sender_display = 'Unknown Sender'
        
        create_time = msg.get('createTime', 'Unknown Time')
        text_content = msg.get('text', 'No text content')
        space_name = msg.get('_space_name', 'Unknown Space')

        # Truncate long messages
        if len(text_content) > 100:
            text_content = text_content[:100] + "..."

        output.append(f"- [{create_time}] {sender_display} in '{space_name}': {text_content}")

    return "\n".join(output)

@server.tool()
@require_google_service("chat", "chat_spaces_read")
@handle_http_errors("get_space_participants")
async def get_space_participants(
    service,
    user_google_email: str,
    space_id: str
) -> str:
    """
    Get participants/members of a Google Chat space.

    Returns:
        str: A formatted list of space participants.
    """
    logger.info(f"[get_space_participants] Space ID: '{space_id}' for user '{user_google_email}'")

    # Ensure space ID has proper format
    formatted_space_id = ensure_space_id_format(space_id)

    # Get space info
    space_info = await asyncio.to_thread(
        service.spaces().get(name=formatted_space_id).execute
    )
    space_name = space_info.get('displayName', 'Unknown Space')
    space_type = space_info.get('spaceType', 'UNKNOWN')

    # Get space members
    members_response = await asyncio.to_thread(
        service.spaces().members().list(parent=formatted_space_id).execute
    )
    members = members_response.get('memberships', [])

    if not members:
        return f"No members found in space '{space_name}' (ID: {formatted_space_id})."

    output = [f"Participants in '{space_name}' (ID: {formatted_space_id}, Type: {space_type}):\n"]
    
    for member in members:
        member_user = member.get('member', {})
        member_type = member_user.get('type', 'UNKNOWN')
        
        if member_type == 'HUMAN':
            member_name = member_user.get('displayName', 'Unknown User')
            member_email = member_user.get('name', '').split('/')[-1] if member_user.get('name') else 'Unknown Email'
            role = member.get('role', 'MEMBER')
            
            # Mark current user
            current_user_marker = " (You)" if member_email == user_google_email else ""
            output.append(f"- {member_name} ({member_email}){current_user_marker} - Role: {role}")
        else:
            # Bot or other non-human member
            member_name = member_user.get('displayName', 'Unknown Bot')
            output.append(f"- {member_name} - Type: {member_type}")

    return "\n".join(output)